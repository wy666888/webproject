<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<script type="text/javascript">
/*
 * 类的继承
 如果两个类A和B，如果可以描述为：B 是 A，则，A和B形成继承关系
 如果B是A，则：
 B继承自A
 A派生B
 B是A的子类
 A是B的父类
 如果A是B的父类，则B会自动拥有A中的所有实例成员。
 新的关键字：
 extends：继承，用于类的定义
 super
 直接当作函数调用，表示父类构造函数
 如果当作对象使用，则表示父类的原型
 
 注意：
 ES6要求，如果定义了constructor，并且该类是子类，则必须在constructor的第一行手动调用父类
 的构造函数
 如果子类不写constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调
 用父类构造器
 【冷知识】
 用JS制作抽象类
 抽象类：一般是父类，不能通过该类创建对象
 正常情况下，this的指向，this始终指向具体的类的对象
 */
class Animal {
	constructor(type, name, age, sex) {
	this.type = type;
	this.name = name;
	this.age = age;
	this.sex = sex;
	}
	print() {
	console.log(`【种类】：${this.type}`);
	console.log(`【名字】：${this.name}`);
	console.log(`【年龄】：${this.age}`);
	console.log(`【性别】：${this.sex}`);
	}
	jiao(){
	throw new Error("动物怎么叫的？");
	}
	}
	class Dog extends Animal {
	constructor(name, age, sex) {
	super("犬类", name, age, sex);
	// 子类特有的属性
	this.loves = "吃骨头";
	}
	print(){
	//调用父类的print
	super.print();
	//自己特有的代码
	console.log(`【爱好】：${this.loves}`);
	}
	//同名方法，会覆盖父类
	jiao(){
	console.log("旺旺！");
	}
	}
	const d = new Dog("旺财", 3, "公");
	d.print();
	console.log(d)
	d.jiao();
</script>
</body>
</html>